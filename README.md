## учебные задания по асинхронному программированию на Python

<hr>
<details>
<summary><strong>my_socket.py</strong></summary>
<br>
Данный код реализует простой сервер на сокетах, который принимает входящие TCP-соединения и отправляет ответы клиентам. Сервер работает в бесконечном цикле event_loop(), который использует функцию select() из модуля select для мониторинга нескольких сокетов на события чтения.

Сначала мы создаем серверный сокет, связываем его с адресом и начинаем слушать входящие соединения. Затем мы добавляем серверный сокет в список to_monitor, чтобы он также был отслеживаем при помощи select.

Функция accept_connectionn() вызывается, когда новое соединение устанавливается с сервером. Она принимает запрос на соединение, получает клиентский сокет и адрес клиента, выводит сообщение о подключении и добавляет клиентский сокет в список to_monitor.

Функция send_message() отправляет ответ клиенту. Она принимает клиентский сокет, получает запрос от клиента, читает содержимое файла "response.txt" и отправляет его обратно клиенту. Если клиент закрывает соединение, то соответствующий сокет удаляется из списка to_monitor.

В цикле event_loop() мы используем select() для следующих событий: чтение (ready_to_read) и запись (_ и _). Если событие произошло на серверном сокете, то вызывается accept_connectionn() для принятия нового соединения. Если событие произошло на клиентском сокете, то вызывается send_message() для отправки ответа клиенту.

В основной ветке программы мы добавляем серверный сокет в список to_monitor, запускаем accept_connectionn() для ожидания первого подключения и запускаем цикл event_loop().
</details>

<hr>
<details>
<summary><strong>my_socket_version_selectors.py</strong></summary>
<br>
все то самое но мониторинг с помошью библиотеки
selectors - это встроенная библиотека Python,
которая предоставляет высокоуровневый интерфейс
 для мониторинга нескольких сокетов/каналов ввода-вывода (I/O) на события (такие как чтение или запись).
 Благодаря этой библиотеке можно создавать многопоточные сервера,
 обрабатывающие несколько клиентских соединений одновременно,
 что делает написание асинхронного I/O более легким и понятным. 
Модуль selectors также может использоваться для работы с другими объектами, 
такими как файлы и таймеры. Он был добавлен в стандартную библиотеку Python начиная с версии 3.4.
</details>

<hr>
<details>
<summary><strong>generetors.py</strong></summary>
<br>
Этот код демонстрирует простую имплементацию концепции генераторов 
и цикла событий для выполнения задач в определенном порядке.
Сначала мы создаем два генератора: gen1 и gen2, 
которые возвращают элементы из строки s и последовательности чисел соответственно.
Затем мы создаем список задач, содержащий эти два генератора.
запускаем цикл while, который будет выполняться до тех пор, пока список задач не станет пустым. На каждой итерации цикла мы берем первую задачу из списка (pop(0)) и попытаемся вызвать функцию next() на этой задаче. Если выполнение прошло успешно, то мы выводим результат (print(i)) и добавляем задачу обратно в конец списка (tasks.append(task)), чтобы она могла быть выполнена в будущем. В случае возникновения исключения StopIteration, что означает, что все элементы были уже получены из генератора,
мы просто игнорируем его и переходим к следующей задаче.
def gen1(s):
</details>