## учебные задания по асинхронному программированию на Python


запуск:
запускаем файлик и в браузер localhost:8000
если все ок, можно открывать много вкладок сразу :muscle:

<hr>
<details>
<summary><strong>my_socket.py</strong></summary>
<br>
Данный код реализует простой сервер на сокетах, который принимает входящие TCP-соединения и отправляет ответы клиентам. Сервер работает в бесконечном цикле event_loop(), который использует функцию select() из модуля select для мониторинга нескольких сокетов на события чтения.

Сначала мы создаем серверный сокет, связываем его с адресом и начинаем слушать входящие соединения. Затем мы добавляем серверный сокет в список to_monitor, чтобы он также был отслеживаем при помощи select.

Функция accept_connectionn() вызывается, когда новое соединение устанавливается с сервером. Она принимает запрос на соединение, получает клиентский сокет и адрес клиента, выводит сообщение о подключении и добавляет клиентский сокет в список to_monitor.

Функция send_message() отправляет ответ клиенту. Она принимает клиентский сокет, получает запрос от клиента, читает содержимое файла "response.txt" и отправляет его обратно клиенту. Если клиент закрывает соединение, то соответствующий сокет удаляется из списка to_monitor.

В цикле event_loop() мы используем select() для следующих событий: чтение (ready_to_read) и запись (_ и _). Если событие произошло на серверном сокете, то вызывается accept_connectionn() для принятия нового соединения. Если событие произошло на клиентском сокете, то вызывается send_message() для отправки ответа клиенту.

В основной ветке программы мы добавляем серверный сокет в список to_monitor, запускаем accept_connectionn() для ожидания первого подключения и запускаем цикл event_loop().
</details>

<hr>
<details>
<summary><strong>my_socket_version_selectors.py</strong></summary>
<br>
все тоже самое но мониторинг с помошью библиотеки
selectors - это встроенная библиотека Python,
которая предоставляет высокоуровневый интерфейс
 для мониторинга нескольких сокетов/каналов ввода-вывода (I/O) на события (такие как чтение или запись).
 Благодаря этой библиотеке можно создавать многопоточные сервера,
 обрабатывающие несколько клиентских соединений одновременно,
 что делает написание асинхронного I/O более легким и понятным. 
Модуль selectors также может использоваться для работы с другими объектами, 
такими как файлы и таймеры. Он был добавлен в стандартную библиотеку Python начиная с версии 3.4.
</details>

<hr>
<details>
<summary><strong>generetors.py</strong></summary>
<br>
Этот код демонстрирует простую имплементацию концепции генераторов 
и цикла событий для выполнения задач в определенном порядке.
Сначала мы создаем два генератора: gen1 и gen2, 
которые возвращают элементы из строки s и последовательности чисел соответственно.
Затем мы создаем список задач, содержащий эти два генератора.
запускаем цикл while, который будет выполняться до тех пор, пока список задач не станет пустым. На каждой итерации цикла мы берем первую задачу из списка (pop(0)) и попытаемся вызвать функцию next() на этой задаче. Если выполнение прошло успешно, то мы выводим результат (print(i)) и добавляем задачу обратно в конец списка (tasks.append(task)), чтобы она могла быть выполнена в будущем. В случае возникновения исключения StopIteration, что означает, что все элементы были уже получены из генератора,
мы просто игнорируем его и переходим к следующей задаче.
def gen1(s):
</details>

<hr>
<details>
<summary><strong>my_socker_version_genirators.py</strong></summary>
<br>
<p>Этот код реализует простейший веб-сервер с использованием асинхронного программирования и блокирующих операций ввода-вывода. Когда сервер получает запрос от клиента, он обрабатывает его и возвращает ответ из файла "response.txt". Функция event_loop() управляет выполнением задач и использует функции select() и генераторы для ожидания готовности к чтению или записи в один из сокетов в словарях to_read и to_write.
</p>

### прочие полезности для понимания:

<p>
yield в Python используется для создания генераторов(пример в generetors.py ) — функций, которые позволяют использовать итерацию без написания полного класса реализующего протокол итератора. Когда функция содержит оператор yield, она становится генератором, который вернет итерируемый объект при вызове. При каждом вызове метода __next __() на генераторе, он выполняет код до первого оператора yield, возвращая значение после yield. Выполнение функции приостанавливается до следующего вызова __next __(), когда код запускается снова сразу после последнего выполнения yield. Это позволяет сохранять состояние функции между вызовами.
</p>
</details>